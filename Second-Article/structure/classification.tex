\section{Classification}
To predict whether or not a usability problem is present a one-class SVM has been used.\todo{LIBSVM}
The one-class SVM is an algorithm used for novelty detection. Novelty detection means that the training data contains no anomalies, which is a requirement we should meet by training on the data from the first two tasks\todo{og m√•ske resting dataen?}
The rest of the data will then act as the prediction set, in which we will try and detect anomalies.

\subsection{Data processing}
For the one-class SVM can work with the data, the data first has to be transformed into feature vectors.
A feature vector is simply a n-space vector containing the features extracted from the a sensor.
A feature vector to each machine is created for each 100~ms in the test.

\subsection{Prediction \& Scoring}
We create a one-class SVM for each of the sensors, and after the model of the one-class SVM is trained on the two first task, the model can then be used to predict on the remaining feature vectors from remainder of the test.
To optimize each machine a grid search for the best parameters
  
The return value from a prediction of a feature vector machine is a binary 1 for a normality and -1 for an anomaly.
The fusion of the results from the different machines will done by a simple voting approach, where a machine must declare whether it has found an anomaly to the given point in time. If x\todo{How many must agree?} sensors agrees the given point will be flagged as an anomaly. 

To fit our use case a formula has been created to score the performance of a SVM model: $score = \frac{a*(PercentEventsHit/TotalEvents)+ b*(1-AnomalyCovered/TotalTime)}{a+b}$
Where an event hit 
Where a and b variables which the reflect the weight for if the formula should reward event hit or time reduction higher.


